* 달 마다 찾아오는 정기 시험

1. C 언어
   자료구조

시험시간: 8 시간(금요일 하루종일)

2. 리눅스 시스템 프로그래밍
   리눅스 커널

시험시간: 8 시간(금요일 하루종일)

3. 공업수학
   펌웨어 프로그래밍(MCU)
   FPGA

시험 시간: 72 시간(금,토,일 - 3 일간)

4. 신호처리(DSP)
   물리
   OpenGL

시험시간: 72 시간(금,토,일 - 3 일간)

* 시험 이후에는 잠시 동안 숙제가 면제됩니다.
  숙제 대신 오답 노트가 있습니다.



* 데이터 타입

int, short, char, float, double, long double

int: 4 byte(32 비트 = 2^32 개를 나타낼 수 있음)
            대략 42 억 9 천만
short: 2 byte(16 비트 = 2^16(65536)개에 해당)
char: 1 byte(8 비트 = 2^8(256)개에 해당)
float: 4 byte
double: 8 byte(2^64)
long double: 12 or 16 byte

데이터 타입에 unsigned 가 붙으면
음수가 존재하지 않음

unsigned 가 없으면 음수값이 존재하게됨



* 음수 빨리 만드는 방법

숫자 1 과 -1 을 더하면 ? 0 이 나와야 한다.
32 비트로 계산하면 좀 빡세니까 8 비트로 하자!

처음에 범 할 수 있는 오류가 맨 앞의 부호 비트만
바꾸면 -1 이 되겠지 하는 오류다.
한 번 부호 비트만 바꿔서 계산해보자

0000 0001	+1
1000 0001	우리의 잘못된 -1
--------------------------------
1000 0010	우리의 잘못된 0

공교롭게도 결과는 0 이 되지 않았다.
뭔가 문제가 있는 것인데
이 문제를 해결하기 위해
2 의 보수라는 것이 나온 것이다.
그러나 CPU 를 설계하는 것이 아닌 이상
자세히 알 필요가 없다.
(CPU 설계쪽에선 매우 중요함)

우리는 빠르게 음수만 획득하면 되기 때문에
아래와 같은 꼼수를 사용하면 아주 쉽게 할 수 있다.

 0000 0001	+1
 1111 1111	-1
------------------
10000 0000	0   (맨 앞의 1 은 버린다)

확인을 해보기 위해서 5 와 10, 28 등에 실험해보자!

  0000 0101	+5
  1111 1011	-5
-------------------
1 0000 0000	0 (이하 동문)

  0000 1010	+10
  1111 0110	-10
-------------------
1 0000 0000	0 (이하 동문)

  0001 1100	+28
  1110 0100	-28
-------------------
1 0000 0000	0 (이하 동문)



* 오버플로우

어떤 데이터 타입이 표현할 수 있는 최대값이 있고
이 범위를 벗어날 경우 오히려 맨 아래로 내려가는 현상

* 언더플로우

위와 마찬가지인데 표현할 수 있는 최소값에서
더 아래로 내려갈 경우 반대로 맨 위로 올라가는 현상

ex) char 타입은 -128 ~ 127 이므로

127 + 1 = -128
-128 - 1 = 127

이 되는 현상이 대표적임

127 + 2 = -127 이 됨
-128 - 2 는 126 이 됨



* 아스키 코드는 왜 배울까 ?

문자가 숫자로 치환이 되기 때문이다.
이것이 가능하기 때문에 암호화에 매우 효율적이다.
기본적으로 우리가 일상에서 사용하는 모든 정보는
유선이 아니라 무선을 통해서 많이 보급되고 있다.
(전화, Wi-Fi, LTE 등등)

문제는 SDR 이라는 근래 아주 핫한 무선 분야다.
이것을 활용하면 무선상의
모든 데이터를 가로챌 수 있다.
암호화가 되어 있지 않다면 id, pw 가 모두 털린다.
(그렇기 때문에 암호화가 필요함)
- 그래도 공인 인증서는 좀 ;;;



* 암호화의 역사 ?

가장 최초로 암호화를 사용한 사람은 로마의 시저 장군
군사 기밀 문서를 중간에 누가 가로챌까봐
암호화 시키는데 모든 문자에 + 3 을 했다.
(그래서 붙은 암호화 별명이 시저 암호화임)
받은 문서를 다시 - 3 해서 복호화하면
실제로 적은 내용을 확인할 수 있었다.

세계 1 차 대전, 2 차 대전등에서도
이 기법은 계속해서 발전해왔고 지금도 ing 이다.
재밌는 실 사례라면 DES 가 하는 알고리즘이 있는데
이 암호화가 누구도 풀 수 없다고 사람들이
자랑을 하고 다녔다.

인도의 어떤 사람이 앉아서 명상을 하다가
이 알고리즘의 해를 찾아서 풀어버린다.
(해를 찾았다는 것이 y = x + 2 와 같이
x 에 값을 넣으면 바로 y[암호]가 튀어나온다는 뜻)

현업: 통신 장비 암호화 프로그램



* 기본 산술 연산자

+: 덧셈
-: 뺄셈
*: 곱셈
/: 나눗셈
%: 나머지 연산



* printf 안에서 '%' 를 출력하고 싶다.

메타 문자 방식(%%)을 사용해서 찍는 방법과
아스키 코드를 이용하는 방법이 있다.
(디버깅 용도로 많이 쓰기 때문에 아무거나 상관없음)

아스키코드 '%' 는 숫자로 37 에 해당한다.
그러므로 % 를 출력하고자 한다면
%c 에 37 을 넣어주면 '%' 를 출력할 수 있다.
(%c 는 char 로 문자 1 개를 출력할 때 사용함)



* 전위, 후위 연산

++ 이 뒤에 오면 더하기 연산이
다음 라인에서 실행되고
++ 이 앞에 오면 먼저 더하기 연산이 실행된다.



* 비트 연산자

AND, OR, XOR, NOT, 쉬프트 연산이 존재함

AND 는 서로 참으로 같을 때만 참(1) 이 된다.
OR 는 둘 중 하나만 참이면 참이 된다.
XOR 는 서로 달라야만 참이 된다.
NOT 은 그냥 뒤집는다.

ex) ~0 = 1
    ~1000 = 0111

쉬프트 연산은 비트를 이동시키는 연산이다.
(결국 2 의 승수로 곱하거나 나누는 연산임)

10 << 1

1010 << 1
10100 = 20

1010 << 3
1010000 = 80

10 >> 2
1010 >> 2 = 10 결과적으로 10 진수 2

* 주의 사항

<< 쉬프트는 그냥 곱하면 되서 문제 없음
>> 쉬프트는 나눌때 소수점 자리를 그냥 버려버림

10 & 3

  1010
  0011 AND
-------
  0010  -->  2

10 | 16

 01010
 10000 OR
-------
 11010  -->  26

10 ^ 5

  1010
  0101 XOR
------
  1111  -->  15 

10000 - 1 = 16 - 1 = 15

10 ^ 3

    1010
    0011 XOR
--------
    1001  -->  9

~10  -->  ~1010

000000000....1010 NOT
-----------------
111111111....0101    -X = -11
00000000000001011    11 = X

이걸 좀 더 빠르게 하는 방법
어차피 컴퓨터 시스템은
형식상 양수에 0 을 포함시키므로
음수가 숫자가 1 더 클 수 밖에 없다.
그러므로 10 을 반전 시키면 -11 이고
100 을 반전시키면 -101 이고
10001237 을 반전시키면 -10001238 이 된다.

usigned char t = 8;

~t = 255 - 8 = 247



* 관계 연산자

<, >, <=, >=, ==, != 

와 같은 연산자는 결과가 참 혹은 거짓임



* 논리 연산자

특별히 주의할 것은 없다.
&&, ||, ! 이 존재한다.
역시 결과는 참과 거짓이며
! 사용시 주의할 것이라면 값이 있으면 거짓
없으면 참이라는 것만 주의하면 된다.



* 숏컷의 이점

기본적으로 if 문을 사용하면 mov, cmp, jmp 형식의
3 개의 어셈블리 코드가 만들어진다.
shortcut 을 사용하면 비교하는 cmp 가 사라진다.
특히 ARM 으로 구현할 때 더더욱 이득을 볼 수 있다.
(코드 최적화 용도로 사용하는 기법임)



* '=' 연산자를 볼 때 주의할 점

C 언어 코드 분석 시에는
항상 오른쪽에서 왼쪽으로 보도록 한다.
그리고 '=' 연산자는 결국 어셈의 mov 와 동일하다.

num1 = num2 = num3; 는
num3 의 값을 num2, num1 에
셋팅하는것과 동일한 역할임



* 통메인 절대 금지

1. 가독성이 심각하게 후짐
2. 디버깅, 유지보수 매우 심각하게 어려움



1. 입력을 6 을 주고 num << 4 를 수행하는 함수를
   작성하고 결과를 출력하도록 만든다.

#include <stdio.h>

int shift_func(int num)
{
	return num << 4;
}

int main(void)
{
	int num = 6, res;
	res = shift_func(num);
	printf("res = %d\n", res);
	return 0;
}

2. 입력에 55 를 넣고 num >> 3 을 수행하는 함수 작성

#include <stdio.h>

int shift_right(int num)
{
	return num >> 3;
}

int main(void)
{
	int num = 55;
	printf("result = %d\n", shift_right(num));
	return 0;
}

3. 입력에 char num1 = 21, num2 = 31 을 넣고
   AND, OR, XOR 를 수행하는 함수를 각각 만든다.
   (함수가 총 3 개 만들어짐 main 포함 4 개)

#include <stdio.h>

char and_func(char n1, char n2)
{
	return n1 & n2;
}

char or_func(char n1, char n2)
{
	return n1 | n2;
}

char xor_func(char n1, char n2)
{
	return n1 ^ n2;
}

int main(void)
{
	char n1 = 21, n2 = 31;
	printf("n1 and n2 = %d\n", and_func(n1, n2));
	printf("n1 or n2 = %d\n", or_func(n1, n2));
	printf("n1 xor n2 = %d\n", xor_func(n1, n2));
	return 0;
}



* scanf 사용법

printf 와 쌍을 이루는 녀석이다.
scanf 의 첫 번째 입력은 "%d" 혹은 "%f", "%lf" 등이 올 수 있다.
그리고 두 번째 입력은 반드시 결과를 받을 주소값을 적어야 한다.
그렇기 때문에 주소값을 의미하는 & 가 들어간 것이다.



* if 문

if 문은 조건을 지정하고 싶을 때 사용한다.
이 안에는 관계 연산자, 조건 연산자 등등이 올 수 있다.
(복잡하게 생각하지 말고 어떤 조건을 만족하는지 안하는지를 생각하면됨)

그리고 if(조건) 에서 조건이 만족되지 않을 경우에는
else 쪽으로 이동하게 되고
만약 여기서도 추가 조건을 비교하고자 한다면
else if(또다른조건) 의 형식으로 여러 조건을 만들 수 있다.

단, 참과 거짓의 지옥은 만들지 않도록!



* switch 문

if 문으로 참과 거짓의 지옥을 만들게 되면
가독성이 심각하게 떨어지는데
switch 는 case 부분에 조건이 있어서
case 에 해당하는 조건만 보고 해당 부분만 확인하면 되므로
if 문을 이용한 참과 거짓의 지옥보다는 가독성이 올라간다.
(그래서 컴파일러를 switch 문을 써서 만든다)

추가적으로 case 안에서의 동작은 break 를 만나기 전까지는 계속된다.



* while 문

if 나 switch 와 같이 조건을 활용한다.
단 작업을 반복시킬 수 있고
조건이 거짓이 될 때까지 반복하게 된다.
(조건이 만족하는 동안 반복하게 된다)



http://cafe.naver.com/hestit/55

2 번, 6 번, 8 번, 9 번, 11 번을 제외함
프로그램을 구현할 때 통 메인으로 짜지 말자.
(반드시 함수를 만들어서 동작하게 만든다)

12 번은 리눅스에서 디버깅 하는 방법을 정리한다.
gdb 상에서 아직 소개하지 않은 명령들
bt
c

이 2 개에 대해 조사해보고 활용해보자 ~













